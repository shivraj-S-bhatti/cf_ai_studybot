/**
 * Study Buddy Agent - AI-Powered Study Companion
 * 
 * This Durable Object implements a comprehensive study assistant using:
 * - Cloudflare Workers AI (Llama 3.1) for natural language processing
 * - D1 Database for persistent storage of user state and quizzes
 * - WebSocket support for real-time chat
 * - Intelligent command parsing for different study features
 * 
 * Key Features:
 * - Topic summarization with AI
 * - Quiz generation with multiple choice questions
 * - Study streak tracking
 * - General conversation handling
 * - Persistent memory across sessions
 */

// Env interface is now generated by wrangler types

/**
 * User state interface for tracking study progress
 */
export interface UserState {
  userId: string;
  streak: number;
  lastTopic?: string;
  lastActive: string;
  quizzes: Quiz[];
}

/**
 * Quiz data structure for storing generated quizzes
 */
export interface Quiz {
  id: string;
  topic: string;
  questions: Question[];
  createdAt: string;
}

/**
 * Individual question within a quiz
 */
export interface Question {
  id: string;
  question: string;
  answer: string;
  options?: string[];
}

/**
 * StudyBotAgent - Main Durable Object class
 * 
 * This class implements the core functionality of the Study Buddy Agent:
 * - Manages user state and study streaks
 * - Handles AI-powered conversations and study features
 * - Provides WebSocket and HTTP API endpoints
 * - Manages persistent storage using D1 Database
 */
export class StudyBotAgent {
  private db: D1Database;
  private state: DurableObjectState;
  private env: Env;

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.db = env.DB;
    this.env = env;
  }

  /**
   * Initialize database schema
   * Creates tables for user states and quizzes if they don't exist
   */
  async initialize() {
    // Initialize database schema
    await this.db.exec(`CREATE TABLE IF NOT EXISTS user_states (user_id TEXT PRIMARY KEY, streak INTEGER DEFAULT 0, last_topic TEXT, last_active TEXT, data TEXT)`);
    
    await this.db.exec(`CREATE TABLE IF NOT EXISTS quizzes (id TEXT PRIMARY KEY, user_id TEXT, topic TEXT, questions TEXT, created_at TEXT)`);
  }

  /**
   * Main chat handler - processes user messages and routes to appropriate features
   * 
   * @param message - User's input message
   * @param userId - Unique identifier for the user
   * @returns AI-generated response based on the message content
   */
  async chat(message: string, userId: string = 'default'): Promise<string> {
    try {
      await this.initialize();
      
      // Get or create user state
      const userState = await this.getUserState(userId);
      
      // Update last active
      await this.updateUserState(userId, { lastActive: new Date().toISOString() });
      
      // Simple command parsing
      if (message.toLowerCase().includes('summarize') || message.toLowerCase().includes('explain')) {
        const topic = this.extractTopic(message);
        return await this.summarizeTopic(topic, userState);
      }
      
      if (message.toLowerCase().includes('quiz me') || message.toLowerCase().includes('generate quiz') || message.toLowerCase().includes('create quiz')) {
        const topic = userState.lastTopic || this.extractTopic(message);
        return await this.generateQuiz(topic, userId);
      }
      
      if (message.toLowerCase().includes('streak') || message.toLowerCase().includes('progress')) {
        return this.getProgressMessage(userState);
      }
      
      // Default response
      return `Hi! I'm your Study Buddy. I can help you:
- Summarize topics (try "summarize machine learning")
- Generate quizzes (try "quiz me on calculus")
- Track your study streak (try "show my progress")

What would you like to study today?`;
    } catch (error) {
      console.error('Error in chat:', error);
      return `Sorry, I encountered an error: ${error instanceof Error ? error.message : 'Unknown error'}`;
    }
  }

  // Summarize a topic using Workers AI
  async summarizeTopic(topic: string, userState: UserState): Promise<string> {
    try {
      const prompt = `Provide a concise, educational summary of "${topic}". Include:
1. Key concepts and definitions
2. 2-3 practical examples
3. Why it's important to understand

Keep it under 300 words and make it engaging for a student.`;

      const response = await this.env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 500,
        temperature: 0.7
      });

      console.log('AI Response:', JSON.stringify(response, null, 2));
      
      // Handle different response formats
      const summary = response.response || 'Sorry, I couldn\'t generate a summary right now.';
      
      // Update user state with last topic
      await this.updateUserState(userState.userId, { 
        lastTopic: topic,
        streak: userState.streak + 1
      });

      return `üìö **Summary of ${topic}**\n\n${summary}\n\nüí° *Great job! Your study streak is now ${userState.streak + 1} days.*`;
    } catch (error) {
      console.error('Error summarizing topic:', error);
      return 'Sorry, I encountered an error while generating the summary. Please try again.';
    }
  }

  // Generate a quiz using Workers AI
  async generateQuiz(topic: string, userId: string): Promise<string> {
    try {
      const prompt = `Create a 3-question quiz about "${topic}". For each question:
1. Write a clear, specific question
2. Provide the correct answer
3. Include 3 plausible wrong options

Format as JSON with this structure:
{
  "questions": [
    {
      "id": "q1",
      "question": "Question text?",
      "answer": "Correct answer",
      "options": ["Option A", "Option B", "Option C", "Option D"]
    }
  ]
}`;

      const response = await this.env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 800,
        temperature: 0.8
      });

      console.log('Quiz AI Response:', JSON.stringify(response, null, 2));
      
      // Handle different response formats
      const responseText = response.response || '{}';
      
      let quizData;
      try {
        quizData = JSON.parse(responseText);
      } catch (parseError) {
        console.error('Failed to parse AI response as JSON:', parseError);
        console.error('Response text:', responseText);
        // Try to extract JSON from the response if it's wrapped in text
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          try {
            quizData = JSON.parse(jsonMatch[0]);
          } catch (e) {
            throw new Error('Could not parse JSON from AI response');
          }
        } else {
          throw new Error('No valid JSON found in AI response');
        }
      }
      
      if (quizData.questions && quizData.questions.length > 0) {
        // Store quiz in database
        const quizId = `quiz_${Date.now()}`;
        const quiz: Quiz = {
          id: quizId,
          topic,
          questions: quizData.questions,
          createdAt: new Date().toISOString()
        };

        await this.storeQuiz(userId, quiz);
        
        // Format quiz for display
        let quizText = `üß† **Quiz: ${topic}**\n\n`;
        quiz.questions.forEach((q, index) => {
          quizText += `**Question ${index + 1}:** ${q.question}\n`;
          q.options?.forEach((option, i) => {
            quizText += `${String.fromCharCode(65 + i)}. ${option}\n`;
          });
          quizText += '\n';
        });
        
        quizText += 'üí° *Answer the questions and I\'ll check them for you!*';
        return quizText;
      } else {
        return 'Sorry, I couldn\'t generate a proper quiz. Please try again with a different topic.';
      }
    } catch (error) {
      console.error('Error generating quiz:', error);
      return 'Sorry, I encountered an error while generating the quiz. Please try again.';
    }
  }

  // Get user progress message
  getProgressMessage(userState: UserState): string {
    return `üìä **Your Study Progress**\n\n` +
           `üî• Study Streak: ${userState.streak} days\n` +
           `üìö Last Topic: ${userState.lastTopic || 'None yet'}\n` +
           `üìù Quizzes Taken: ${userState.quizzes.length}\n\n` +
           `Keep up the great work! üéâ`;
  }

  // Handle general questions with AI
  async handleGeneralQuestion(message: string, userState: UserState): Promise<string> {
    try {
      const prompt = `You are Study Buddy, an AI-powered study companion. The user asked: "${message}". 
      
Respond as a friendly, helpful study assistant. Keep your response concise (under 100 words) and encourage them to use your study features like:
- Topic summarization
- Quiz generation  
- Progress tracking

Be encouraging and mention their current study streak of ${userState.streak} days if it's greater than 0.`;

      const response = await this.env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 200,
        temperature: 0.7
      });

      const aiResponse = response.response || 'Hello! I\'m Study Buddy, your AI study companion.';
      
      // Update user state
      await this.updateUserState(userState.userId, { 
        lastActive: new Date().toISOString(),
        streak: userState.streak + 1
      });

      return aiResponse;
    } catch (error) {
      console.error('Error handling general question:', error);
      return `Hello! I'm Study Buddy, your AI study companion. I can help you with topic summaries, quizzes, and tracking your study progress. What would you like to study today?`;
    }
  }

  // Helper methods
  private extractTopic(message: string): string {
    // Simple topic extraction - look for words after "summarize" or "explain"
    const match = message.match(/(?:summarize|explain|quiz me|generate quiz|create quiz)\s+(.+)/i);
    return match ? match[1].trim() : 'general knowledge';
  }

  private async getUserState(userId: string): Promise<UserState> {
    const result = await this.db.prepare(
      'SELECT * FROM user_states WHERE user_id = ?'
    ).bind(userId).first();

    if (result) {
      return {
        userId,
        streak: (result.streak as number) || 0,
        lastTopic: result.last_topic as string | undefined,
        lastActive: (result.last_active as string) || new Date().toISOString(),
        quizzes: await this.getUserQuizzes(userId)
      };
    }

    return {
      userId,
      streak: 0,
      lastActive: new Date().toISOString(),
      quizzes: []
    };
  }

  private async updateUserState(userId: string, updates: Partial<UserState>): Promise<void> {
    await this.db.prepare(`
      INSERT OR REPLACE INTO user_states (user_id, streak, last_topic, last_active)
      VALUES (?, ?, ?, ?)
    `).bind(
      userId,
      updates.streak || 0,
      updates.lastTopic || null,
      updates.lastActive || new Date().toISOString()
    ).run();
  }

  private async getUserQuizzes(userId: string): Promise<Quiz[]> {
    const result = await this.db.prepare(
      'SELECT * FROM quizzes WHERE user_id = ? ORDER BY created_at DESC'
    ).bind(userId).all();

    return result.results?.map((row: any) => ({
      id: row.id as string,
      topic: row.topic as string,
      questions: JSON.parse((row.questions as string) || '[]'),
      createdAt: row.created_at as string
    })) || [];
  }

  private async storeQuiz(userId: string, quiz: Quiz): Promise<void> {
    await this.db.prepare(`
      INSERT INTO quizzes (id, user_id, topic, questions)
      VALUES (?, ?, ?, ?)
    `).bind(
      quiz.id,
      userId,
      quiz.topic,
      JSON.stringify(quiz.questions)
    ).run();
  }

  // WebSocket handler for real-time chat
  async fetch(request: Request): Promise<Response> {
    try {
      if (request.headers.get('Upgrade') === 'websocket') {
        const { 0: client, 1: server } = new WebSocketPair();
        
        this.handleWebSocket(server);
        
        return new Response(null, {
          status: 101,
          webSocket: client,
        });
      }

      // Handle HTTP requests
      const url = new URL(request.url);
      
      if (url.pathname === '/api/chat' && request.method === 'POST') {
        const { message, userId } = await request.json() as { message: string; userId: string };
        const response = await this.chat(message, userId);
        
        return new Response(JSON.stringify({ response }), {
          headers: { 'Content-Type': 'application/json' }
        });
      }

      return new Response('Not found', { status: 404 });
    } catch (error) {
      console.error('Error in fetch:', error);
      return new Response(JSON.stringify({ 
        error: `Internal server error: ${error instanceof Error ? error.message : 'Unknown error'}` 
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }

  private handleWebSocket(webSocket: WebSocket) {
    webSocket.accept();
    
    webSocket.addEventListener('message', async (event) => {
      try {
        const { message, userId } = JSON.parse(event.data);
        const response = await this.chat(message, userId);
        
        webSocket.send(JSON.stringify({ response }));
      } catch (error) {
        console.error('WebSocket error:', error);
        webSocket.send(JSON.stringify({ 
          error: 'Sorry, something went wrong. Please try again.' 
        }));
      }
    });
  }

  // Schedule daily reminders (simplified version)
  async scheduleReminder() {
    // For now, we'll skip scheduling and just log
    console.log('Daily reminder scheduling not implemented in this version');
  }
}
